# name: test/sql/cte/recursive_cte_key_aggregation.test
# description: Recursive CTEs with USING KEY and aggregations
# group: [cte]

statement ok
PRAGMA enable_verification;

query II
WITH RECURSIVE tbl(a, b) USING KEY (a , max(b)) AS (
	SELECT 1, 5
		UNION
	SELECT a, b - 1
	FROM tbl
	WHERE b > 0)
TABLE tbl;
----
1	5

query II
WITH RECURSIVE tbl(a, b) USING KEY (a , avg(b)) AS (
	SELECT 1, 5
	  UNION
	SELECT a, b - 1
	FROM tbl
	WHERE b > 0)
TABLE tbl;
----
1	2.5

query III
WITH RECURSIVE tbl(a, b, c) USING KEY (a , avg(b), list(c)) AS (
	SELECT 1, 5, NULL :: DOUBLE
	  UNION
	SELECT tbl.a, tbl.b - 1, rec.b
	FROM tbl, recurring.tbl AS rec
	WHERE tbl.b > 0)
TABLE tbl;
----
1	2.5	[NULL, 5.0, 4.5, 4.0, 3.5, 3.0]

statement ok
CREATE TABLE knows(person1id INT, person2id INT);

statement ok
INSERT INTO  knows VALUES (1, 2), (2, 3), (1, 3);

query IIII
WITH RECURSIVE dvr(here, there, via, len) USING KEY (here, there , arg_min(via, len), min(len)) AS (
	SELECT n.person1id AS here, n.person2id AS there, n.person2id AS via, 1 AS len
	FROM knows AS n
		UNION
	SELECT n.person1id AS here, dvr.there, dvr.here AS via, 1 + dvr.len AS len
	FROM dvr
	JOIN knows AS n ON
	(n.person2id = dvr.here AND n.person1id <> dvr.there))
TABLE dvr
ORDER BY here, there;
----
1	2	2	1
1	3	3	1
2	3	3	1

# use correlated column in recursive CTE with aggregation
query IIII
SELECT  *
FROM    range(1, 4) AS _(l),
   LATERAL (
     WITH RECURSIVE cte(a, b, c) USING KEY (a , list(b)) AS (
       SELECT 1, l, 3
         union
       SELECT a, l + 1, c - 1
       FROM   recurring.cte
       WHERE  c > 0)
	TABLE cte) ORDER BY l;
----
1	1	[1, 2, 2, 2]	0
2	1	[2, 3, 3, 3]	0
3	1	[3, 4, 4, 4]	0

#######################################################################
# Every column reference in the aggregate list must be unique

# Duplicate column reference in aggregate list
statement error
WITH RECURSIVE tbl(a,b,c) USING KEY (a, b , list(c), max(c)) AS (
	SELECT 1, 1, NULL
    	UNION
    SELECT tbl.a, tbl.b - 1, a.b
	FROM tbl, recurring.tbl AS a
	WHERE tbl.b > 0)
SELECT * FROM tbl;
----
<REGEX>:.*referenced multiple times.*

# Duplicate column reference in aggregate list and key list
statement error
WITH RECURSIVE tbl(a,b,c) USING KEY (a, c , list(b), max(c)) AS (
	SELECT 1, 1, NULL
    	UNION
    SELECT tbl.a, tbl.b - 1, a.b
	FROM tbl, recurring.tbl AS a
	WHERE tbl.b > 0)
SELECT * FROM tbl;
----
<REGEX>:.*cannot be used as both key and aggregate.*

# Duplicate column reference in key list
query III
WITH RECURSIVE tbl(a,b,c) USING KEY (a, a , list(b)) AS (
	SELECT 1, 1, NULL :: INT[]
    	UNION
    SELECT tbl.a, tbl.b - 1, a.b
	FROM tbl, recurring.tbl AS a
	WHERE tbl.b > 0)
SELECT * FROM tbl;
----
1	[1, 0]	[1]

# Use alias to set aggregation destination
query II
WITH RECURSIVE tbl(a,b) USING KEY (a , string_agg(':a') AS b) AS (
	VALUES (1,2), (1,3)
		UNION
	SELECT a, b + 1
	FROM tbl
	WHERE b < 4)
SELECT * FROM tbl;
----
1	:a,:a,:a,:a,:a

# constant as an aggregate argument
query II
WITH RECURSIVE tbl(a,b) USING KEY (a , string_agg(b, ', ') ) AS (
    SELECT 1, 5
		UNION
	SELECT tbl.a, tbl.b - 1
    FROM tbl
    WHERE tbl.b > 0)
TABLE tbl;
----
1	5, 4, 3, 2, 1, 0

# All aggregate functions
query II
WITH RECURSIVE tbl(a,b) USING KEY (a , any_value(b) ) AS (
	SELECT 1, 5
		UNION
	SELECT tbl.a, tbl.b - 1
	FROM tbl
	WHERE tbl.b > 0)
TABLE tbl;
----
1	5

query II
WITH RECURSIVE tbl(a,b) USING KEY (a , arbitrary(b) ) AS (
	SELECT 1, 5
		UNION
	SELECT tbl.a, tbl.b - 1
	FROM tbl
	WHERE tbl.b > 0)
TABLE tbl;
----
1	5

